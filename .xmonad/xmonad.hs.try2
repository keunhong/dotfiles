import XMonad
import XMonad.Config.Gnome
import XMonad.Hooks.ManageDocks
import XMonad.Util.EZConfig
import qualified XMonad.StackSet as W
import XMonad.Hooks.ManageHelpers
import XMonad.Layout.NoBorders
import XMonad.Layout.Decoration

import qualified Data.Map as M
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.EwmhDesktops

--import XMonad.Util.Font

--import Monad
import Data.Monoid (All (All), mappend)

-- Pipe Stuff
import XMonad.Util.Run
import XMonad.Hooks.DynamicLog


----
import Control.OldException
import Control.Monad
import DBus
import DBus.Connection
import DBus.Message
 
import XMonad.Layout.NoBorders
import qualified Data.Map as M
import XMonad.Prompt
import XMonad.Prompt.Shell
import XMonad.Prompt.XMonad
 
import qualified XMonad.Actions.Submap as SM
import qualified XMonad.Actions.Search as S
 
import XMonad.Layout.FixedColumn
import XMonad.Actions.CycleWS
 
------


getWellKnownName :: Connection -> IO ()
getWellKnownName dbus = tryGetName `catchDyn` (\ (DBus.Error _ _) ->
                                                getWellKnownName dbus)
 where
  tryGetName = do
    namereq <- newMethodCall serviceDBus pathDBus interfaceDBus "RequestName"
    addArgs namereq [String "org.xmonad.Log", Word32 5]
    sendWithReplyAndBlock dbus namereq 0
    return ()

main :: IO()
main = withConnection Session $ \ dbus -> do
        putStrLn "Getting well-known name."
        getWellKnownName dbus
        putStrLn "Got name, starting XMonad."
        --h <- spawnPipe "xmobar"
        xmonad $ ewmh gnomeConfig
            { terminal              = "gnome-terminal"
            , modMask               = mod4Mask
            , focusFollowsMouse     = False
            , workspaces            = ["1:main","2:dev","3:im","4:email","5","6","7","8","9","0"]
            , layoutHook            = avoidStruts $ smartBorders $ layoutHook gnomeConfig
            , manageHook            = myManageHook <+> manageHook gnomeConfig
            , normalBorderColor     = "#000000"
            , focusedBorderColor    = "#4878CC"
            , borderWidth           = 2
            , handleEventHook       = fullscreenEventHook `mappend` handleEventHook gnomeConfig
            , startupHook = startup
            --, logHook = dynamicLogWithPP $ myPP { ppOutput = hPutStrLn h }
            ,logHook                 = myLogHookWithPP $ defaultPP {
                                        ppOutput   = myOutput dbus
                                        , ppOrder    = take 1 . drop 2
                                        , ppTitle    = pangoColor "#003366" . shorten 120
                                        , ppUrgent   = pangoColor "red"
                                        }
            } `additionalKeys`
                [ ((mod4Mask, xK_z), spawn "exe=`dmenu_path | dmenu` && eval \"exec $exe\"")
                ]

-- Log Hook PP
myPP = defaultPP  { ppCurrent = wrap "<fc=white,#4878CC> " " </fc>" 
                     , ppSep     = ""
                     , ppWsSep = ""
                     , ppVisible = wrap "<fc=black,DarkSlateGray4> " " </fc>" 
                     , ppLayout = \x -> "<fc=#4878CC,black>:: "
                                  ++ case x of
                                       "Mirror ResizableTall"   -> "MTiled"
                                       "ResizableTall"          -> "Tiled"
                                       "Tabbed Bottom Simplest" -> "Tabbed"
                                       "Tabbed Simplest"        -> "Tabbed"
                                       _                        -> x
                                  ++ "</fc> "
                     , ppTitle = \x -> if null x
                                         then ""
                                         else "<fc=#89A0C9,black>[" ++ shorten 83 x ++ "]</fc>"
                     , ppHidden = wrap "<fc=#aaa,black> " " </fc>"
                     }

-- Startup Script
startup :: X()
startup = do{
            spawn "~/.xmonadrc"
            }

-- Manage Hooks
myManageHook = composeAll
    [ isFullscreen --> doFullFloat
    , className =? "Xfce4-notifyd"      --> doF W.focusDown
    , className =? "Xfce4-notifyd"      --> doFloat
    , className =? "Firefox"            --> doShift "1:main"
    , className =? "Google-chrome"      --> doShift "1:main"
    , className =? "Gnome-terminal"     --> doShift "2:dev"
    , className =? "Terminal"           --> doShift "2:dev"
    , className =? "Pidgin"             --> doShift "3:im"
    , className =? "Lanikai"            --> doShift "3:im"
    , className =? "Evolution"          --> doShift "4:email"
    --, className =? "MPlayer"            --> doFullFloat
    --, className =? "Gnome-mplayer"      --> doFullFloat
    ]



myLogHookWithPP :: PP -> X ()
myLogHookWithPP pp = do
    ewmhDesktopsLogHook
    dynamicLogWithPP $ pp
 
myOutput dbus str = do
  let str'  = "<span font=\"Terminus 9 Bold\">" ++ str ++ "</span>"
      str'' = sanitize str'
  msg <- newSignal "/org/xmonad/Log" "org.xmonad.Log" "Update"
  addArgs msg [String str'']
--   If the send fails, ignore it.
  send dbus msg 0 `catchDyn`(\ (DBus.Error _name _msg) -> return 0)
  return ()
 
pangoColor :: String -> String -> String
pangoColor fg = wrap left right
 where
  left  = "<span foreground=\"" ++ fg ++ "\">"
  right = "</span>"
 
sanitize :: String -> String
sanitize [] = []
sanitize (x:rest) | fromEnum x > 127 = "&#" ++ show (fromEnum x) ++ "; " ++
                                       sanitize rest
                  | otherwise        = x : sanitize rest
